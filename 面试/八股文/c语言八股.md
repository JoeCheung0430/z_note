# 1 栈和堆得区别？

### a）申请方式

 栈的空间由操作系统自动分配和释放，堆上的空间手动申请和释放

### b）申请大小限制不同

栈空间是固定的，使用连续空间像低地址扩展；堆是不连续的空间，是一种动态分配的内存区域，是用链表存储的像高地址扩展。

### c)申请效率不同

堆空间由系统分配，效率快，且不会产生内存碎片；堆空间由程序员分配，效率慢，且会产生内存碎片。

栈空间：4M；堆空间：1G-4G

# 2 什么是野指针 产生的原因是什么？

指向已被释放或无效的内存地址的指针是野指针。

1.内存释放后未置空指针

2.返回局部变量的指针

3.未初始化指针

# 3 DMA有什么用

DMA是直接内存访问，它运行内存直接与外设进行数据传输，而不需要CPU的干预，这可以提高传输数据的效率，减轻CPU的负担，让CPU去处理其他事务。

# 4 进程间通信方法

1、管道模型：比如cat xx.txt | grep -n 'xxx' 这个'|'可以看作一个单向的匿名管道，使得前后两个进程之间进行通信，前一个命名的输出作为后一个命令的输入，该管道使用结束则立即销毁。命名管道在linux中以文件的形式存在，只要访问该文件就可以实现任意两个进程间的通信，命名管道可以看作是是硬盘上存在的设备文件，所以打开需要使用open。
2、消息队列模型：比如生产者消费者模式，一端生产一端消费数据。遵循严格的先进先出。
3、共享内存模型：多用于传输一些大文件，如果采用管道或者消息队列传输大文件，涉及到重复拷贝，比较消耗性能，因此模拟多线程，在内存中开辟一块特殊的内存用于多个进程共享访问。也是进程间最高效的通信方式。
4、信号量机制：可以看作是计数器，可以用来控制多个进程对共享资源的访问。它通常是一种锁机制，实现进程、线程对临界区的同步及互斥访问。

5、socket：适用于不同机器网络之间的进程通信，在本地也可以作为两个进程的通信方式。

6、信号：用于通知接收进程某个事件已发生，比如按下ctrl+c

# 5 程序中的内存分配方法

### a）静态分配

全局变量、静态变量、局部变量

### b）动态分配

malloc：分配指定大小的内存，返回指向这块内存的指针。如果分配失败，返回NULL

calloc：分配指定数量的内存块，每块大小相同，并初始化为零。返回指向内存块的指针

realloc：给动态分配的空间分配额外的空间，用于扩充容量

free：释放先前分配的内存，释放的内存可以再次被分配

# 6 malloc和new的区别

1.new是C++中的关键字，需要编译器的支持；malloc是标准库中的函数，需要头文件的支持。

2.使用new创建对象会调用构造函数，使用malloc创建对象不会调用构造函数。

3.使用new不需要指定对象的大小，使用malloc需要指定对象的大小。

4.new返回的是一个对象的指针，类型严格与对象匹配，不需要强转换；malloc返回的是void*，需要通过强转换转换成我们需要的类型。

# 7 为什么局部变量未赋值时，每次初始化的结果是不确定的

1. 局部变量分配在栈上，栈内存不会自动清零。
2. C语言标准规定未初始化的局部变量的值是未定义的。
3. 为了性能考虑，C语言不会自动为局部变量初始化。

# 8 c语言volatile作用和用法

volatile关键字主要是防止编译器对变量进行优化即告诉编译器每次存取该变量的时候都要从内存去存取而不是使用它之前在寄存器中的备份，可以提供对特殊地址的稳定访问。

### 哪些情况会使用：

（1）并行设备的硬件寄存器

 （2）中断服务程序中修改的供其他程序检测的变量需要加volatle

 （3）多线程应用中被几个任务共享的变量

# 9 编译有几个阶段每个阶段做什么事情

预处理——处理以#开头的预处理命令，生成.i文件

编译——翻译成汇编文件，生成.s文件

汇编——将汇编文件翻译成可重定位目标文件，生成.o文件

链接——将所有单独预编译好的目标文件进行合并，得到可执行文件

# 10 linux用户态怎么进入内核态

内核态就是ring0，使用su-切换；通过软件中断，调用int $0x80的汇编指令产生程序异常。

# 11 简单描述一下数组指针和指针数组

### 数组指针

数组指针就是指向数组的指针，它表示的是一个指针，这个指针指向的是一个数组，它的重点是指针

### 指针数组

指针数组表示的是一个数组，要使用该数组值的时候都要使用取址符

# 10 简单描述linux设备驱动中的总线 设备和驱动的关系

总线将设备和驱动绑定。在系统每注册一个设备的时候，会寻找与之匹配的驱动；相反的，在系统每 注册一个驱动的时候，会寻找与之匹配的设备，而匹配由总线完成。一个现实的Linux设备和驱动通常都需要挂接在一种总线上。设备与驱动的关联通过总线的match()方法进行匹配，驱动挂载总线时与所有设备进行匹配，设备挂载总线时与所有的驱动进行匹配，所以驱动和设备的挂载无先后之分。匹配成功后会通过调用驱动的probo()方法来初始化设备。

# 12 在FreeRTOS中二值信号量和互斤量的区别?

# 13 在FreeRTOS中任务通知的运行机制是怎么样的?

# 14 什么情况下会栈溢出?如何避免?

# 15 TCP和UDP的区别
